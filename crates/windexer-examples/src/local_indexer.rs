use {
    anyhow::Result,
    clap::Parser,
    std::{
        path::PathBuf,
        sync::{Arc, Mutex},
        time::{Duration, Instant},
    },
    tokio::time::interval,
    tracing::{error, info, debug},
    tracing_subscriber::{EnvFilter, fmt::format::FmtSpan},
    windexer_store::{
        Store,
        StoreConfig,
    },
};

#[derive(Parser, Debug)]
#[clap(
    version, 
    about = "Fast indexer for local test data",
    long_about = "Indexes data generated by local_gen with high performance"
)]
struct Args {
    #[clap(long, default_value = "./data")]
    data_dir: String,
    
    #[clap(long, default_value = "30")]
    metrics_interval_seconds: u64,
    
    #[clap(long, default_value = "1000")]
    batch_size: usize,
}

// Struct to track indexing metrics
struct IndexingMetrics {
    start_time: Instant,
    accounts_processed: usize,
    transactions_processed: usize,
    blocks_processed: usize,
    last_processed_slot: u64,
    accounts_per_second: f64,
    transactions_per_second: f64,
    blocks_per_second: f64,
}

impl Default for IndexingMetrics {
    fn default() -> Self {
        Self {
            start_time: Instant::now(),
            accounts_processed: 0,
            transactions_processed: 0,
            blocks_processed: 0,
            last_processed_slot: 0,
            accounts_per_second: 0.0,
            transactions_per_second: 0.0,
            blocks_per_second: 0.0,
        }
    }
}

impl IndexingMetrics {
    fn update_rates(&mut self) {
        let elapsed = self.start_time.elapsed().as_secs_f64();
        if elapsed > 0.0 {
            self.accounts_per_second = self.accounts_processed as f64 / elapsed;
            self.transactions_per_second = self.transactions_processed as f64 / elapsed;
            self.blocks_per_second = self.blocks_processed as f64 / elapsed;
        }
    }
    
    fn log_metrics(&self) {
        info!(
            "ðŸ“Š Indexing metrics: {} accounts ({:.2}/s), {} txs ({:.2}/s), {} blocks ({:.2}/s), last slot: {}",
            self.accounts_processed,
            self.accounts_per_second,
            self.transactions_processed,
            self.transactions_per_second,
            self.blocks_processed,
            self.blocks_per_second,
            self.last_processed_slot,
        );
    }
}

#[tokio::main]
async fn main() -> Result<()> {
    let args = Args::parse();
    
    let env_filter = EnvFilter::try_from_default_env()
        .unwrap_or_else(|_| {
            EnvFilter::new("local_indexer=info")
        });

    tracing_subscriber::fmt()
        .with_env_filter(env_filter)
        .with_span_events(FmtSpan::CLOSE)
        .with_ansi(true)
        .with_target(true)
        .with_thread_ids(true)
        .with_thread_names(true)
        .init();

    let store_path = PathBuf::from(format!("{}/local_gen/store", args.data_dir));
    
    let store_config = StoreConfig {
        path: store_path,
        max_open_files: 1000,
        cache_capacity: 100 * 1024 * 1024, // 100 MB
    };
    
    info!("ðŸ’¾ Initializing storage");
    let store = Store::open(store_config)?;
    let store = Arc::new(store);
    
    let metrics = Arc::new(Mutex::new(IndexingMetrics::default()));
    let metrics_clone = metrics.clone();
    let metrics_interval = args.metrics_interval_seconds;
    
    // Spawn metrics logging task
    tokio::spawn(async move {
        let mut interval = interval(Duration::from_secs(metrics_interval));
        loop {
            interval.tick().await;
            
            let mut m = metrics_clone.lock().unwrap();
            m.update_rates();
            m.log_metrics();
        }
    });
    
    // Process accounts
    let store_clone = store.clone();
    let metrics_clone = metrics.clone();
    let batch_size = args.batch_size;
    
    tokio::spawn(async move {
        let mut last_slot = 0;
        loop {
            let accounts = store_clone.get_recent_accounts(batch_size);
            if accounts.is_empty() {
                break;
            }
            
            let len = accounts.len();
            for account in accounts {
                debug!("Processing account: {}", account.pubkey);
                last_slot = last_slot.max(account.slot);
            }
            
            let mut m = metrics_clone.lock().unwrap();
            m.accounts_processed += len;
            m.last_processed_slot = last_slot;
        }
    });
    
    // Process transactions
    let store_clone = store.clone();
    let metrics_clone = metrics.clone();
    let batch_size = args.batch_size;
    
    tokio::spawn(async move {
        let mut last_slot = 0;
        loop {
            let transactions = store_clone.get_recent_transactions(batch_size);
            if transactions.is_empty() {
                break;
            }
            
            let len = transactions.len();
            for tx in transactions {
                debug!("Processing transaction: {}", tx.signature);
                last_slot = last_slot.max(tx.slot);
            }
            
            let mut m = metrics_clone.lock().unwrap();
            m.transactions_processed += len;
            m.last_processed_slot = last_slot;
        }
    });
    
    // Process blocks
    let store_clone = store.clone();
    let metrics_clone = metrics.clone();
    let batch_size = args.batch_size;
    
    tokio::spawn(async move {
        let mut last_slot = 0;
        loop {
            let blocks = store_clone.get_recent_accounts(batch_size);
            if blocks.is_empty() {
                break;
            }
            
            let len = blocks.len();
            for block in blocks {
                info!("Processing block: {} (slot {})", 
                    block.pubkey,
                    block.slot);
                last_slot = last_slot.max(block.slot);
            }
            
            let mut m = metrics_clone.lock().unwrap();
            m.blocks_processed += len;
            m.last_processed_slot = last_slot;
        }
    });
    
    // Wait for Ctrl+C
    tokio::signal::ctrl_c().await?;
    info!("Shutting down...");
    
    info!("âœ… Indexer shutdown complete");
    Ok(())
} 